- description : (book정리) book review한 것으로 directory가 필요하지 않은 것들을 한번에 모아둔 페이지이다.
- tag : book , summary , my-summary , DE , data-science , bigData
- date : 2023-01-01

TOC
- [1. \[부동산 투자, 개인으로 할까? 법인으로 할까?\] 2023-10-08 (총 60 page:밀리의 서재)](#1-부동산-투자-개인으로-할까-법인으로-할까-2023-10-08-총-60-page밀리의-서재)
- [2. \[김정환:나의 첫 투자수업2\_투자편\] 2021-06-20](#2-김정환나의-첫-투자수업2_투자편-2021-06-20)
- [3. \[:부의 시나리오\] 2021-07-11](#3-부의-시나리오-2021-07-11)
- [4. Youtube : (미주은이 똑똑한거네)](#4-youtube--미주은이-똑똑한거네)
- [5. Software engineering at google](#5-software-engineering-at-google)
  - [5.1. Part I. 전제 : SW engineering이란?](#51-part-i-전제--sw-engineering이란)
  - [5.2. Part II. 문화](#52-part-ii-문화)
  - [5.3. Part III. 프로세스](#53-part-iii-프로세스)
  - [5.4. part IV. 도구](#54-part-iv-도구)
  - [김진형 교수님의 책을 보는 중  - 204.06](#김진형-교수님의-책을-보는-중----20406)


------------------------

# 1. [부동산 투자, 개인으로 할까? 법인으로 할까?] 2023-10-08 (총 60 page:밀리의 서재)
- 사유 : 법인을 준비해야 할 것 같아서, 퇴직 이후 건보료도 문제일수 있기 때문이다.
- p23 : 건축물 유형별 주차 요건
- 주택인 부동상으로는 다가구 주택 한 채만 보유하고, 해당 다가구 주택의 공시가가 12억 미만이라면 , 해당 다가구에서 받은 주택 임대 수입이 얼마든 세금을 전혀 내지 않는 전액 비과세가 가능하다.


# 2. [김정환:나의 첫 투자수업2_투자편] 2021-06-20

https://digital.kyobobook.co.kr/digital/guide/guideMain.ink?guidePage=guide01&guide_menuNo=1#section02
부채 비율(부채/자본)이 200%는 넘지 않아야 한다.
재무제표 분석 3가지 방법 : 1. 기업의 현재/과거 상황 - 매출 이익의 증감.  2.경쟁기업과의 비교 - 차이와 원인 3.산업의 평균비율 분석-업종 평균 ROE와 비교 

1.안정성 : 유동 비율 , 부채 비율 , 차입금 의존도 , 자기자본비율,고정비율
2.수익성 : 매출액 영업이익률,매출액계속사업이익률, 총자산경상이익률, 이자 보상 배율 , 금융비용부담률,차입금평균 이자율
3. 성장성 : 매출액 증가율 , 총자산 증가율, 유형자산 증가율

영업활동 현금 흐름이 (-) 인 기업은 무조건 피해야 합니다. 영업이익이 영업활동현금흐름보다 낮다면 건강하지 못한 신호

부채비율은 200% 이내이면 안전하다. 

재무제표에서 중요한 것 : 매출액 , 영업이익 증가 , 투자금액 (투자를 해야 성장한다.)
1. 대차대조표 : 자산 = 부채 + 자본
2. 손익계산서 : 매출액에 따른 영업이익. 각각의 매출액 대비 비율을 통해 전년 대비 혹은 전분기 대비 기업이 어떠한 방향으로 변화하고 있는지 추세
3. 현금흐름표 

EPS (주당순이익)
CAPEX(capital expenditures:기업이 돈을 벌기 위해 설비나 장비,건물 등에 투자하는 것) : 업업이익이 갑자기 잘 나올때는 감가상각비가 줄거나 끝난 경우이므로 잘 체크해야 한다.

기본 5개 수치
1. 주당순이익 (EPS) = 당기순이익/주식수 
2. 자기자본이익률 (ROE) : 경영효율을 보는 대표적인 재무지표
3. 주가수릭비율 (PER=Multiple) : 주가가 1주당 수익의 몇배
4. 주가순자산비율 (PBR) = 주가/주당순자산
5. 주당순자산가치 (BPS) = (기업의 총자산 - 부채)/발생주식수 : 청산가치으로 안전마진 역할을 합니다.

<32> 적정 주가는 어떻게 계산하나요?  먼저 영업이익을 보라. 
영업이익 (또는 당기순이익) * ROE => 시가총액 이 적당
김정환 적정주가 만능 공식 
1. EPS * ROE(100, ROE는 비율이므로 100을 곱함) => 적정주가
2. ROE는 미래의 PER이므로 현재의 ROE는 재무제표에 나오지만, 미래의 가치를 따져야 하므로 투자 성공률을 놓이려면 산업과 기업의 성장성과 미래를 내다보는 통찰력을 키워야 한다.
  영업이익 (또는 당기순이익) * ROE => 시가총액 이 적당
공식 적용 관련 예 : 셀트리온(고평가) , 기업은행(저평가)
ROE를 적용하는 이유는 성장성을 본 것으로 , PER은 계속 변하게 되는 것이다. 
아는 만큼 보인다.

멀티플
1. 매출액 , 이익
2. 성장성 : ROE를 멀티플에 넣는 것은 성장성에 배팅하는 것. 
3. 인력 구성
4. 대외 변수 : 글러벌 경제 성장 , 호황 , 거기경제 , 소비패턴..
5. 최근의 전방산업 (반도체) 같은 것에 더 주기도 함. 예전에는 8, 지금은 15~20


BPS X (ROE)^2 = EPS X ROE
Bookvalue per share , return on equity , earning per share

미래 기대되는 산업 : mini LED
Amortization 무형자산 : 특허 , 지재구너 , 브랜드 , 영업권 등..
그래서 워렌버핏은 감가상각비를 +로 계산을 하기도 한다고 함.


<34> PER
한국거래소 > 시장정보 > 통계 > 지수 > 주가지수 > PER > 계열 기간 선택후 조회 -> 챠트 클릭
android-주식탐구

<36> 매출이 증가하는 기업 (안전마진 있으면 더 좋음) / 지속적인 성장 / 스토리가 있는 주식
기업 방문 중요. 
좋은 기업을 빨리 알아볼수 있는 방법은 무엇일까? 부지런히 check필요
DART (금융감독원 전자공시시스템) dart.fss.or.kr

<37> 기업을 철저히 분석해서 미래 실적을 예측해야 한다. (우리가 이게 가능할까?) 

<38> 고급투자자가 되려면 이성적으로 팩트를 제대로 체크하고 투자해야 한다. 
매일매일 산업분석 리포트 / 관심기업의 리포트를 찾아 읽어야 한다. 종목에 대한 지식을 쌓는 것이 중요하다.  그래서 , 세상 돌아가는 흐름이 보여야 한다. 
상상이 필요
주가는 이상 급등을 보이기도하는데 , 따라 들어가면 실패 입니다. 그 전에 종목을 뽑아 현재 저평가인지 분석하고 매입할 가격과 비중을 결정하는게 고수의 비법입니다. 
자산의 전력적 배분이나 종목의 매수/매도 타이밍 , 포트폴리오 구성을 자신의 방법으로 만들어야 합니다. 
확신을 가질때까지 기업을 분석하라. 1~2종목 깊게 파보자
자신이 원하는 기준에 맞춰 리스트를 뽑은 다음 섹터별로 나눠살펴봅니다. 

<39> 정부 정책에 반하지 마라. 우선순위가 무엇인지 빠르게 파악하고 수혜기업을 선정해야 한다. 
이명박 - 건설 기계 , 박근혜 - IT SW  , 문재인 - 바이오 2차전지 언택트 게임
확정된 미래 수익을 포기하자 마라.-> 일반적으로 수주 잔고에서 나온다. - 사업 개발 확정
새 정부가 들어서기 전에 대통령 후보의 공양이나 정권인수위원회에서 발표한 정책을 분석하면 실패가 줄어든다.


앞으로는 ESG가 중요.
이런 기업을 찾아라. 공부해라.
ESG 등급 : 사단법인  KCGS(www.cgs.kr)에서 기업의 ESG등급을 평가 제공한다. 

배당 : HTS에서 "시가배당률"

<45> 투자자는 가격이 하락할때 공포를 이기는 법을 배워야 하며 , 가격이 상승할때 너무 열광하거나 욕심 부리지 않는 법을 깨달아야 한다. (세스 클라만)

인적 불할 하는 회사들은 좋은 방향으로 지켜볼 필요가 있습니다.

상장 폐지 : 4년 연속 영업손실 , 대주주 지분률 살피자. (3년 지분 변동 추이) 

<47> 싸게 사고 기다림의 고통 . 시장은 끊임없이 상승한다. 한푼이라도 아껴서 좋은 종목의 수량을 쌀때 꾸준히 늘려나가야 한다. 
매수는 무엇보다 저렴한 가격에 선취매하는 것이 중요. (선 분석 필요) 산 물량의 30~50% 물량은 내가 생각한 투자 아이디어가 변하지 않을때까지 들고 갑니다. 
***기회가 오지 않으면 사지 않습니다.  "저가다" 
***글로벌 분위기를 보고 관심 있는 종목이 싸 보이면 분할 매수하고 , 보유 종목이 비싸 보이면 분할 매도합니다. 
0. 적정치 확인 : 사업 실현성을 보고 단기/중기/장기 매매 모멘텀
1. 시간의 가치 고려. 1년에 200%목표일때 , 1달 150%되면 매도하라. (비정상적으로 오르면 팔고 다시 떨어졌을때 기회를 봐라.)
2. 안전마진이 더 확호되는 더 좋은 종목이 보이면 갈아탄다.
3. 단기로 얻은 수익은 장기로 오를 종목에 꾸준한 분할 매수
4. 시장이 힌들리거나 위험이 보일때는 현금 확보
5. 매수 (분할) / 매도 (한번에 전량) 는 기계적으로 ..

***우리가 기업을 볼때는 Top-Down방식으로.  큰 사업의 변화를 먼저 보고 그 산업안의 기업을 보면서 어떤 기업이 좋아질지 미리 분석하는 거야. 올해부터 성장할 산업들 , 내년에 성장할 산업들을 미리 알아보고 그에 맞는 기업들을 찾는거지

<49> 숨겨져 있는 맛집이 유명해지면 더 이상 가지 않는다. 
Ride the Tide : 파도를 타되 가장 높은 곳이 아닌 파도의 밑을 타세요. 정부의 정책도 항상 잘 읽고 있어야 한다.

<50> 포트폴리오 변화
비중조절은 분기 실적이 좋다고 예상되면 비중 더 투입 (실적을 미리 알고 있을때) / 테마주도 실적을 바탕으로 (씨젠) / 드론과 같이 육성한다는 말만 믿지 말고 산업이 제대로 발전하는 시점에 선취매해야 한다. 
기업가치와 중요한 것은 수급 : 어떤 기업을 얼마 만큼 샀고 , 어느 가격대에 많이 팔고 있다는 것을 숫자로 3년동안의 수글을 체크
분기 실적이 기다려지는 것이 가치 투자의 기본입니다. 

<51>
***주식투자의 주가가 상승 추게에 있을때 해야 수익을 낼수 있는데 불행히도 일부 투자자들은 반대로 움직입니다. 주가가 상승하는 동안에는 비싸다는 느낌, 너무 오른다는 느낌이 들어 매수할 생각조차 못하지만 정작 주가가 하락하기 시작하면 매수하려 합니다. 주가가 강하게 하락하면 싸다고 생각하기 때문입니다. 물론 시장에서 소외되고 저평가된 좋은 주식을 충분한 분석을 통해 미리 발견하여 바락에서 담으려는 전략적인 매수는 예외 입니다. 

<53> 상승장 / 하락장
하락장은 외국인이 이끌고 , 상승장의 끝은 개인들이 이끕니다. 
상승장의 초입에선 집중투자를 , 상증장 진입 후엔 종목의 숫자를 늘려나갑니다. 그리고, 다시 하락장엔 종목의 고체매매를 통해 믿을수 있는 몇몇 종목으로 다시 집중 투자를 해야 합니다.
트랜드를 읽고 흐름 위에 올라탈수 있는 유연한 사고를 지녀야 합니다. 
포지션이 하방으로 크게 내려가는 경우는 많아야 1년에 한두번 정보 밖에 없습니다. 시장은 계속 자신의 자리를 찾아 돌아갑니다. 다만 시장이 하방으로 내려갈때 저점을 확인할수 없기에 분할 매수를 해야 합니다.
상승장세가 끝아면 순홤내 장세(섹터가 돌아가면서 오르는 것)가 옵니다. 
마지막은 유동성장세가 옵니다. 불나방들까지 증시에 참여 (묻지마투자)

<54> 철저히 기록하라. : 하루도 쉬지 않고 공부해야 자신감이 붙는다.
미래 이슈를 선점한다는 것은 그 이슈가 처음 나왔을때부터 선점하라는 것은 아닙니다. 매출로 드러날때까지는 오랜 시간이 소요되기 때문에 면밀하게 관찰해 나가면서 어느 정도 숙성되어 내년 정도면 관련 기술로 실제 수익이 날 수 있겠다는 판단이 설때가 적정한 선점 타이밍 입니다.


철주 생각 : 싸게 사는게 답 / 테마는 돈다 / 분산 투자를 해서 산다. / 80%는 상승장이다 / 많이 떴다고 판단하여 팔았을 경우 이익본 돈은 아직 테마가 가지 않은 곳에 투자를 하여 사이클을 노린다. / 재무책을 보니 그것을 보는 이유는 안 좋은 기업을 걸러내기 위한 것이라고함. 현금흐름등이 불량한 것을 꼭 걸러야 위험이 작아짐 (나는 1,2등 기업만 투자한다면) / 
AI에 진짜 데이터만 좀 많이 넣어주고 알아서 식을 만들라고 하고 , 그때 그 값들로 순간순간이 제일 잘 맞는 것으로 예측치를 뽑아내게 하는 것이 켄지 같은 인공지능일까?
10~20의 소수 종목을 제대로 분석하라.
미주은이 분석하는 방법이 매우 유용하며 , 그렇게 발생할 issue까지 고려하는 것이 제일 좋다. 
아는 사람들에게 가서 밥 사면서 미주은 처럼 분석하는 방법과 그들의 추천 종목과 분석 방법과 이유를 들어야 한다. 구제적 계획을 만들어야 한다. (심재훈, 구용회,경제방,)
















# 3. [:부의 시나리오] 2021-07-11









# 4. Youtube : (미주은이 똑똑한거네)
2021.07.04 [고급]초(超)성장주 밸류에이션 4가지방법
영업이익의 10배가 시가총액이다. 
1.**실적이 나오는 기업 : 10년안에 벌어들일 이익이 시가 총액이다. 카카오가 지금은 영업이익이 1조인데 시가총액은 70조. 10년후에는 5조 이상을 벌수 있을까?**
2.PER기준 3 , 4배 일때는 PSR 기준 : 매출액의 6 ~7배 
3.메타버스/바이오 같은 기업 : 미국의 valuation을 기준으로 적용. 성공할때마다 valuation을 추가해주는 방법. 기술만 있는 기업들. 
4. 페이스북 / 아마존 / 구글 / 로블록스 : 가입자수에 따른 1인당 평균 매출액



# 5. Software engineering at google
## 5.1. Part I. 전제 : SW engineering이란?
- 하이럼 법칙 : 많은 사용하가 있는 API가 중요함.. 명세서 만은 중요하지 않다.
  - tiger : backward compatibility : 고객을 불편하게 하지 말자.
- 비욘세 법칙 : if you like it then you should have put a ring on it. 네가 좋아했다면 CI 테스트에 넣어두었어야지!!  확장성이 좋아진다. 
  - tiger : sldd collection
- 조직이 10배로 , 엔지니어가 할일이 많아질때 , 코드가 복잡해질때 -> 해당 경웨 대해 자동화 하거나 최적화할 수단이 있는가?   (NO이면 terrible)
  - tiger : merge tool ...
- 인프라는 더 자주 변경할수록 변경하기가 오히려 쉬워집니다. (P20) upgrade를 겪지 않는 코드는 적고 , 정기적인 upgrade를 수행하기때문에 중복되는 과정을 찾아 자동화 노력
  - tiger : TIDL with backward compatibility and upgrade incrementally , sldd will help to be stable code with various test.
- 원점회귀 (shift left) : 초반에 잡아라. : 개발 프로세스 초기에 품질 ,안정성 , 보안 문제를 찾아 알려주는 도구와 관례를 제공하는 일은 구글 인프라팀의 주요 목표 중의 하나
  - tiger : tgier-desktop & TAF (sldd , coverity , unittest)
- 트레이드 오프와 비용 : 어떤 주제든 한 명의 결정권자를 두고 , 잘못된 결정이라 판단될때 찾아가야 할 사람들의 에스컬레이션 경로도 명확히 정의해야 합니다. 독재가 아니라, 어디까지나 합의를 통해 도출
  - we : 우리는 엔지니어들이 행복을 느끼게 만들고 일에 집중하고 참여할수 있게 해주는가?  필요한 것은 무엇일까?
  - me : '내가 시켰으니까'는 어떤 일을 수행하는 이류로는 아주 끔찍합니다.
- 의사결정 근거 자료 : 모든 sw 엔지니어링 조직은 연산 자원 , 엔지니어 시간 , 그 외 정지적으로 활용하는 다른 정랼적 데이터의 혀냊 비용을 추적하고 관리할수 있는가? :  데이터 중심 문화로 잘못을 빨리 알수 있다. 
  - we : 우리는 가능한가?  근거로 활용할 data 가 있는가? 어떻게 만들어야 할까? 어떤 작업들이 필요할까?  혹시 collab에 이미 우리가 이런 류의 정리가 잘 만들어둔 것이 있지 않을까?
  - me : 판단을 내리고 그 판단을 검증하는게 중요.  (측정할수 없는 요인들까지 고려)
- p61. 사례 : 분산 빌드 : 최고의 합법적인 핑계 (컴파일중) -> 제번스의 역설 (효율이 좋아지면 자원 소비가 늘어난다.:분산 빌드 지원했더니 아무도 최적화는 할 생각을 안하고 의존성이 비대해지는 등의 소비가 늘어난다.)
  - we : 현재 엄청 시간을 줄였지만, 적당한 compile 시간은 얼마일까요?  우리가 더 할 일은 없을까요?  

## 5.2. Part II. 문화
- Sw 개발은 '팀의 단합된 노력'의 결실입니다. 그래서 엔지니어링팀이 성공하려면 겸손,존중,신뢰 라는 핵심 원칙에 맞게 여러분 자신의 행동을 바로 잡아야 합니다.
- 천재라고 해서 괴짜처럼 행동하는 게 용서받는 시대는 지났습니다. 천재든 아니든 사회성이 부족한 사람은 팀원으로 적합하지 않기 때문이죠. 그래서 우리의 경력을 미래로 이어주는 핵심은 다른 사람과 얼마나 잘 협력하느냐입니다.
- 숨기려 하지 말고  , 초기부터 아이디어를 구하고 모두 open하라.  눈이 많아야 프로젝트가 탈선하지 않고 올바른 방향으로 간다. 
  - we : 우리는 그렇게 하고 있는가?
- 실패는 선택이다.  : 실패한 근본 원인을 분석하여 문서로 남기는 것이 실수로부터 배우는 핵심입니다. 
  - we : 우리는? p89
    - 모호함을 뚦고 번창한다 : 합의를 통한 문제 진전
    - 피드백을 소중히 한다. 
    - 저항(항상성)을 극복한다. (관성 극복)
    - 사용자가 우선
    - 팀에 관심을 기울인다. : 동료들의 입장에서 생각하고 존중하며 팀의 결집을 위해 누가 시키지 않더라도 적극적으로 돕습니다.
    - 옳은 일을 한다. 
- 지식 공유 (FA)
  - SW 엔지니어는 오래 갈수 있을까?
  - 그룹 내 소통 패턴 p97
    - me : 내가 진심으로 그 사람을 돕기위한 설명을 하고 있는가?  귀찮아 하지는 않는가?
  - 끈기를 하기조 상냥하세 답변해줘야 사람들이 안심하고 도움을 청하는 환경이 조성됩니다. 
  - 맥락 이해하기 : 수년간 사용해온 인프라의 핵심 코드가 우리에게 맡겨졌고 원 작성자는 회사를 떠났다면 ,  기존 코드를 공부하는 데 시간을 쓰기 보다는 차라리 다시 짜고 싶어 집니다. 이때 성급히 결정하지 말고 다음을 주목 : '무언가를 옮기거나 바꾸려면 그게 왜 그 자리에 있는지부터 이해하자'   이후 결정
  - 적자 생존 & 문서
    - g3doc : I’m the Google g3doc lead. g3doc is our internal engineering documentation platform, integrated with our source control system.  https://www.usenix.org/conference/srecon16europe/program/presentation/macnamara
    - Docs as Code : https://cchesser.github.io/docs-as-code/
    - tiger : doxygen comments , we can control documents with Code
  - 구글 동료 상여 제도 : we : already doing...
- 팀 이끌기
  - 장애물 치우기 : 기술적 , 조직적
  - 엔지니어 연결 
  - 명확한 목표 세우기
    - we : 우리의 방향은 세워져있다. 
  - 행복한지 확인하기
    - me : 해보자  '뭐 필요한 것 없어요?'
- 성장하는 조직 이끌기
  - 눈 가리개 찾기 : 뭔가 잘못됬지만 그냥 지나가는 것을 찾아 새로운 전략 모색
  - 핵심 트레이드 오프 파악하기
  - Always Be Leaving : 너 없어도 잘되게..
  - 좋은 관리 : 관찰가 경청 95% , 절묘하고 시의적절한 개입 5%
    - me : 나는 빵점~~
  - 공 떨어뜨리기 : 놔두면 해결되는 것도 많고 , 급한 것이 아닌 중요한 것에 집중하라. 
  - 에너지 관리하기
    - me : 나는 꼭 해야함!
- 엔지니어링 생산성 측정하기 : 결정을 내릴 권한을 본인들이 가지고 있는 경우에만 의미가 있다.
  - 데이터 주도 회사
    - we : 우리의 데이터는 무엇인가?  MM 을 산정할때 우리의 기준은 표준 MM + 어떤 것을 기준으로 잡은 것인가?
  - GSM framework : 개발자들 입장에서의 Goal(목표:최종결과) , Signal(신호:목표도달이라고 느끼는 무언가) , Metric(척도:무엇을가지고측정)
  - QUANTS : 특정 요소를 개선하느라 실수로 다른 요소를 희생하는 일을 막기 위함
    - Quality of the code
    - Attention from engineers : 몰입도
    - Intellectual complexity : 복잡도
    - Tempo and velocity : 얼마나 빨리 할수 있는지
    - Satisfaction : 엔지니어가 도구에 얼마나 만족하는지?

## 5.3. Part III. 프로세스
- 스타일 가이드와 규칙 : 단순 formatting이 아닌 구글에서는 막는 기능도 포함되는 듯
  - we : 빨리 넣읍시다. 어렵지 않습니다. 우리가 사용하는 모든 system에서 동작하도록 제약을 피해갈수 있는 방안으로 하면 좋을 듯 합니다. (가능하면 기본 package 사용 : 기본 Package들을 모으는 일이 필요할까?) 
  - 규칙은 최소화 / 일관성 / 읽는 사람 기준 (쓰기 편함보다 읽기 편함으로) / 실용적 예외는 허용
    - 확장 및 조직 성장에도 도움이 됨. 장기적으로 유지보수 프로세스가 간소화 됨
  - me : 코드 스타일과 일관성에 대해서 telephony에서 어떤 일이 일어나는지를 알아볼 것. (p210,211)  tidl에 같이 적용할 것을 찾자.
  - me : we : 몇명에게 권한을 주어 c++ style , python style 에 대한 권한을 주자. 거기서 정해지는 것을 따르자. (필요시 초청)  이것에 따른 review (mod도 고려)는 무조건 필수 (해당 사람에게 꼭 review를 받아야함.)
    - C++ tip : unique_ptr + move
    - 교육도 필수 & 도구 활용
  - 오류 검사기 : coverity , clang-tidy , error prone
  - 코드 포맷터 : clang-format , yapf , gofmt , dartfmt , buildifier
    - me : 우리도 blaze와 같은 닉네임을 달고 소통하자. 재미나지 않을까?
- 코드 리뷰 : precommit review
  - 코드를 읽는 사람을 배려하라. 단지 나만의 코드가 아니다. 
  - me : 작은 기능으로 나누고 , commit을 너무 큰 단위로 하지 않는다.  (사실 크면 못 봄.)  
    - we : 작게 나누면 jenkins system이 난리 날 듯!
  - 제대로 하면 자신의 코드를 한번 더 들여다보게 된다.
  - 지식 공유
    - 구글에서는 메일을 걸러 읽는 일은 많아도 , 코드 리뷰 요청에 응답하지 않는 경우는 거의 없습니다 
    - we : 진짜 되는가?
  - 변경 설명 잘쓰기
    - we : 우리가 부족한 것 아닐까요?
  - 리뷰어는 최소한으로
  - 가능한 한 자동화 하기
- 문서 자료
  - 구글에서 문서 자료를 개선하고자 해본 시도 중 가장 성공적이었던 방법은 '문서 자료를 코드처럼 취급' 하여 엔지니어링 워크플로에 통합하는 것
  - p256, 257 :  문서 작성이 필요한 이유
  - 문서 자료는 코드와 같다.
    - me : 우리는 doxygen에 코드에 넣도록 하자. sh 과 python에 대해서도 이런 부분이 없으면 review시 -1 점을 주도록 하자.
      - https://google.github.io/styleguide/shellguide.html
      - pydoc
    - we : 코드를 작성하면 그 위에 왜 이렇게 했는지 적게 하자.  나부터 잘 해야 한다. 
  - markdown
  - 파일 주석
    - we : TIDL에 적용되어있는가?
  - 랜딩 페이지
    - we : tiger collab이 이런 역할을 하고 있는가?
  - we : README.md를 각 모듈들도 가지고 있어야 한다.  tidl 반영 : 추후 이것으로 doxygen을 만들면 되도록 유도~~
  - me : '누가' 를 독자가 중심이 되어야 한다는 것은 나는 잊는다.... 명심 필요
  - 핵심 : 문서자료는 시간이 지나고 조직이 커질수록 더 중요 / 문서 자료 변경도 워크플로에 포함 / 하나의 문서는 하나의 목적에 집중 / 문서는 자신이 아니라 독자를 위해서 써야 한다.
- 테스트
  - 자동 테스트 : 버그 잡기아 SW가 변화할수록 지원
  - 테스트 : API + input + expected output + controlled condition (꼭 챙겨야함)
  - 집단 지성은 팀 전체의 이익으로 환원 -> 자동 테스트
    - we : test case 보유가 관건 , 계속 추가되어 경험이 쌓이는 환경 구축 필요
  - 테스트가 실패하면 수분내에 해결하도록 하는 팀
    - we : we can do it.
  - we : 프로그램에 대한 점검사항으로 우리가 가지고 있는 list가 있는가? manager이면 기본 가져야 하는 것 , 각 모듈이면 기본적으로 가져야 하는 것
    - me : 관련 내용 확인 필요하며, 그 내용들이 sldd에 기본 들어가게 해야함.
  - 테스트 코드가 주는 혜택 p 288
    - 디버깅 감소
    - 자신있게 변경
    - 더 나은 문서 자료
    - 더 단순한 리뷰
    - 사려 깊은 설계
    - 고품질의 릴리스를 빠르게
  - test suite
    - **불규칙 하게 실패하는 테스트의 원인을 몇 번만 조사하다 보면 테스트 suite 에 대한 팀의 믿음이 금방 깨집니다. 이 단계에 들어사면 엔지니어들은 테스트가 실패하더라도 더는 신경쓰지 않습니다.**
    - 바람직 tescase 비율 : unit test (80%) , 통합 (15%) , 종단간(5%)
    - 오류 되는 상황을 일부러 발생 시킵니다.
  - 테스트를 존중하는 문화로 바꾸는 일과 더불어 linter를 개발가거나 문서 자료를 보강하는 등, 안 좋은 테스트를 만드는 실수를 줄여주는 테스트 인프라에도 투자를 해야 합니다. 지원해야 할 프레임워크아 도구의 수를 줄여서 투자대비 효율을 높이세요. 테스트 관리 비용을 낮추는데 투자하지 않으면 종국에는 엔지니어들이 테스트가 전혀 가치 없다고 결론 내게 될 것 입니다.
  - 오리엔테이션 과정에 1시간짜리 테스트의 다양한 이점을 다룸. 
- 단위테스트
  - 질 나쁜 테스트는 체크인 되기 전에 수정돼야 합니다.
    - we : 우리가는 test case를 제대로 만들고 있나? 특히 , unit test를 너무 형식적으로 하고 있는 것은 아닌가? API 기준이므로 조금만 더 생각해서 넣어두면 어떨까?  우리는 unit test를 매번 수행하여 확인을 하고 있는가?
  - **변하지 않는 테스트로 만들기 위해 노력하자.**
    - 리팩토링 , 새 기능 추가 , 버그 수정시에는 기존 테스트를 손 볼 일이 없어야 한다는 것 입니다.
    - 공개 API만을 사용하여 test한다. 
  - 테스트 하나 하나가 명확한 test가 되어야 합니다.  
    - 테스트의 구조는 행위가 부각되도록 구성하자. : 행위 (given:시스템설정 , when:시스템수행작업  , then:결과검증)
    - 테스트에 논리(연산자,반복문, 조건문)를 넣지 말자.
    - 실패 메시지를 명확히 작성하자.
  - 테스트와 코드 공유 : DRY(Donot repeat yourself)가 아니라 DAMP(Descriptive and meaningful phrase)! - 단순 명료하게 만들어준다면 다소 중복도 상관없음.
  - setup 잘 정의 필요
- 테스트 대역 (test double) : mocking
  - java : mockito , c++: googlemock , python : unittest.mock
  - we : 우리는 각 모듈마다 자신의 대역을 제공해주고 있는가?
  - 교훈(P345) : 테스트 대역을 쉽게 만들어주는 모의 객체 프레임워크를 과용하면 위험하다는 것 입니다. 의존하는 다른 모듈들에 신경쓰지 않고 원하는 코드 조각에 집중하는 테스트를 매우 쉽게 만들수 있었죠. 이런 테스트를 세수 없이 양산하며 몇 해가 지나자 커다란 대가를 치르게 되었습니ㅏ. 버그를 잘 찾아내지 못했고 끊임없이 보수를 해야 했음.  오늘날에는 많은 엔지니어가 모의 객체 프레임워크를 피하고 실제에 더 가까운 테스트를 작성합니다. 
  - python / javascript 같은 동적 타입 언어에서는 개별 함수 나 메서드를 동적으로 교체하는게 가능합니다. (의존성 주입)
  - we : 우리는 classical test(모두 있는 기반 test) 와 mockist test (모의 기반 test) 중에 어느 것이 적당할까?
  - me : 우리 코드는 실제로 return 값보다는 argument에서 값을 얻어오기에 , return에 대한 것을 쉽게 대치시켜줄수 있으며, arguement를 통해서 받는 값을 직접 종류별로 입력해주면 되므로 mockist로 해도 classical 과 다르지 않을 듯!
  - 종류 : mock, fake , stub 
- 더 큰 테스트
  - we : 우리는 sld , auto..csv를 가지고 이것을 수행하고 있다.
  - 더 큰 테스트가 갖춰야 할 것 : 소유권 문제 , 표준화 
  - we : telematics라는 한정이 있어서 인지 , 팀 내부적으로는 우리가 잘하는데, 문제는 testcase를 QE에서 우리가 예상하지 않는 것 까지 작성을 해야 하는게 맞는데~~
- 폐기 (deprecation)
  - we : roseRT 구현 방식 폐기
  - 구글에서 엔지니어링팀에 권장하는 고려사항
    - 내 제품의 고객이 잠재적인 대체품으로 이주하기가 얼마나 쉬울까?
    - 내 시스템을 한 부분씩 점진적으로 교체하려면 어떻게 해야 할까?
  - p418 : 권고 폐기의 한계.
    - we :  TIDL 로 고친후에 will be depricated 확실하게 표기 : 점검도 해야함.  그리고, 실제 제품을 돌렸을때 (TAF , 실제 서비스를 debug mode에서 동작시킬때) 각 함수가 얼마나 호출되는지 check하는 나타내는 것 추가 할 것 - log에서 뽑아내면 될 것으로 보인다. 그러므로 , 함수 통계 자료로 사용되는 LOG에 대해서는 따로 표기되게 TIDL에 포함시켜두어야 할 것으로 보인다. deprecaed가 거의 안 쓰이는지 확인 필요 (TidlManager.cpp에만 LOG를 추가하면 될 것으로 보인다.) TIDL로 된 것은 interface를 바로 부르는 것을 잡아내는 것을 START ~ END  조합과 grep으로 해결될 수 있다. non-TIDL인 것은 service ID를 가지고 비교하는 작업을 해야 한다.
  - 강제 폐기 : 기존 시스템을 완전히  제거하는 팀을 따로 둔다.
    - me : 역시 구글...  우리는 위에서 결정해도 '알아서 해. 언제까지 할건데' 로 끝나는데.    보통 '뭐가 필요해' 가 나와야 하는데.  
  - tools : 
    - https://github.com/google/codesearch
    - https://github.com/kythe/kythe  : kythe와 grok이 통합되었다고함.
    - 퇴행을 실수 수준에서 방지하기 위해 tricorder라는 정적분석 프레임워크를 이용
    - tiger : tiger에 적용 시키면 어떨까?  이리 opengrok으로 되어져있는가?
    - we : config.local/diff.pl 과 같은 뭔가를 만들어 모든 source들에거 사용하면 안되는 list가 포함되었는지를 check하여 에러를 발생하게 하게 하는 것을 만드는 것이 중요할 것이로 보인다. 2개가 있어야 할 것으로 보인다. diff.pl에서 deny할 전체 시스템 적인 list 와  각 module마다 allow 를 하는 list를 따로 가지게 해야할 것으로 보인다. 

## 5.4. part IV. 도구
- 버젼 관리와 브랜치 관리 (version control system)
  - 브랜치 관리 : 단일 진실 공급원으로 좁힌다.
    - 개발 브랜치는 만들어도 결국 master로 병합되어야 한다.
    - 릴리즈 브랜치는 대체로 무해하지만,  없이 그냥 지속적으로 배포 (continuouse deployment)가 잘 되게 릴리즈 branch를 따로 만들지 않고 잘 관리하며 지속적으로 개발되는 것이 최고
    - 구글 : one repository & owner 개념
    - 중요한 것은 모노리포냐 아니냐가 아니라 '원-버젼' 원칙을 최대한 준수하는 것 입니다.
      - tiger : we : 우리(tiger)가 잘하고 있다는거~~~
- Code Search
  - web이므로 크래시 리포팅 도구나 로그 출력에 등장하는 스택 프레임에서도 해당 소스 코드로 바로 링크 해 줍니다.
    - we : memory leak / crash등이 생기는 call stack을 보여줄때 해당부분에 대한 opengrok link를 보여주면 매우 유용할 것이다.
  - API 제공 : vim , emacs , intellijJ용 검색 과 상호 참조 플러그인도 만들어 쓴다고함.
    - me : code search opengrok visual studio code 한번 해보자. 
      - opengrok도 PC에 깔리나?  https://manime.tistory.com/entry/opengrok-windows%EC%97%90-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0   
- 빌드 시스템과 빌드 철학
  - bazel : 아티팩트 기반 빌드 시스템 (artifact based build system)
    - functional programming 언어와 유사
    - manifest에 정의
    - 의존성 그래프를 만들어 , 수행할 순서를 정하여 이미지를 만들어준다.
    - me : bazel을 이용하여 TIDL을 compile할수 있는가? 지금은 그냥 makefile 로 task based build system인 것이다. 
      - 헉, 여기서도 외부서버 응답하지 않을 때는 처리해주지 않으므로 , 미러링을 하라네요.
      - yocto 로 만들어야 할까요?  이것만 따로 build 되게도 , 전체안에서 되게도...
    - 분산빌드
      - 원격 캐싱 포함
    - vendoring : third_party 소스를 모두 checkin해두어 내부 의존서으로 변환시켜 , 외부서버 무응답에서 자유로와진다.
- Critique : 구글의 코드 리뷰 도구
  - A Closer Look at 12 Powerful Code Review Tools : https://kinsta.com/blog/code-review-tools/
  - me : github에서 제공하고 같이 사용 가능한 것을 살펴보는게 더 효과적일 것으로 생각됨.
- 정적분석
  - **개발자의 시간은 소중합니다**
    - 개발자 행복에 집중하자
      - 거짓양성을 줄이자. 
    - 정적분석을 개발자 워크플로에 반드시 끼워넣자.
    - 사용자가 기여할 수 있도록 하자.
  - 구글은 정적분석을 컴파일러에 통합
    - we : 우리는 그러기 힘들다. 다 가지고 있는게 아니어 통합의 한계가 많다. 그래서 우리는 Daily Test 에서 정보 제공.  (jenkins에 넣을수 있지만, 시간이 너무 많이 걸린다. 그리고, performance 문제)
- 의존성 관리
  - 의존성 관리는 우리에게 접근 권한이 없거나 속을 들여다볼수 없는, 조직 외부에서 이루어지는 변경 때문에 일어나는 문제를 다룹니다.
  - 의존성 관리 문제보다는 소스 관리 문제가 생각하기도 훨씬 쉽고 처리 비용도 훨씬 저렴합니다.
  - we : 질문 : 모듈마다 같은 library의 다른 버젼을 이용하는 것이 가능한 것인지요?   의존성 문제가 있었던 적이 있던가?
  - OSS
- 대규모 변경 : LSC (large-scale change)
  - 분류
    - 코드베이스 전반을 훑는 분석 도구로 찾은 공통 안티패턴 청소
    - 폐기 대상 API 호출 대체 (scoped_ptr -> std::unique_ptr)
    - (컴파일러 업그레이드 등) 저수준 인프라 개선사항 활성화
    - 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션
  -  유령의 묘지 (haunted graveyard) : 아주 중요한 system인데 누구도 변경할수 없는 곳
     -  해결책은 충실한 테스트
  - 환경 (도구 , 스타일 가이드 등)을 단순화해 일관성을 높이면 인력을 재배치할때도 좋고 컴퓨터가 변경을 자동으로 수행하는데도 좋습니다. 예를 들어 구글에서는 변경사항을 코드베이스에 반영하기저네 프리서브밋 검사가 수행되도록 하고 있습니다. 
  - 구글 TAP (Test Automation Platform)이라는 것을 쓴다네요. 엄청난 테스트를 해서 report 제공
- CI (Continuous Integration)
  - CI가 제공하는 피드백을 많은 사람이 볼수 있어야 합니다. 구글 직원이라면 누구든 거의 모든 코드를 볼 수 있게 하는데, 테스트 리포트에 대해서도 비슷한 입장입니다. 통합 테스트 리포트 시스템을 이용하여 빌드와 테스트 결과를 로그까지 누구든 쉽게 볼 수 있게 하는 것이죠.
  - 각 빌드 , 테스트가 어디서 멈췄고 , 어디서 실행했고 , 누가 실행했는지도 알 수 있습니다. 분명한 실패인지 비결정적인 결과인지를 구분해주는 시스템도 마련했습니다. 구글 차원에서의 데이터를 동계내어 구분해주므로 엔지니어들은 자신의 변경 때문에 다른 프로젝트의 테스트까지 실해한 것인지를 스스로 판단하지 않아도 된다. 
    - me : tiger profiler의 생각과 비슷
  - 테스트에 실패하면 '빌드 실패'
  - 프리서밋만으로 부족한 이유 : 한참 기다려야하면 생산성이 떨어진다. 테스트 범위를 제한하거나 문제를 발견할 가능성이 높은 테스트를 찾는 모델을 고안하는 등의 방식으로 프리서브밋때 수행할 테스트를 잘 선별해야 합니다.
    - we : lvl 1 - jenkins TAF test
    - 팀별로 빌드 경찰을 둡니다. 
  - 포스트 서브밋때는 더 오래 걸리고 약간 불안정한 테스트도 포함시킬수 있습니다. 불안정한 테스트를 프리서밋에 넣었다가 에라가 나면 포스트 서밋으로 바꿔주는 것도 방법이다.
    - we : lvl 2, 3 - daily , weekly test
  - hemetic test (밀폐 테스트) : 모든 것을 갖춘 테스트 환경에서 수행하는 테스트 
  - 범인 색출 속도를 높이기 위해 실패시 TAP은 자동으로 변경 각각을 독립적으로 다시 테스트합니다. 이 방식은 때론 시간이 오래 걸릴수 있습니다. 그래서 이진 검색으로 범인을 색출하는 도구를 만들어서 개인 개발자가 이용할수 있도록 배포했습니다. 
    - we : TAF에도 가능할까? (2023?) 우리도 개발자들이 각기 사용하게 만들어주어야 하나?  이진 검색으로 뒤쪽에서 동작시켜주어야 하나?
      - 지금도 1,2,3 세명이 동시에 commit 한 것이 각각이 성공하고 merge된 후에 , 4번 commit하는 사람이 동작시킬때 에러가 발생한다면  , 1,2,3중에 누가 에러를 만들어낸 것일지?
      - 우리가 1,2,3 중에서 뭐가 먼저 반영되었는지는 알수 있다. 1은 되고,  2,3이 1을 반영하지 않은 것에서 출발하는데 , 이것을 어떻게 처리해주어야 할까요?
  - 테이크아웃(example)팀은 작은 샌드박스 환경을 만들어서 프리서브밋 단계에서 각 인스턴스를 테스트했습니다. 모든 서버가 성공적으로 구동되면 통과입니다. 그 결과 설정 잘못으로 서버가 손상되는 일이 95%를 잡아냈고 일일 배포 실패를 절반으로 줄였습니다.
  - 향후 개선 사항으로 버그 신고와 태그 달기 자동화를 생각해 볼 수 있습니다.
    - we : 우리는 지금 준비중~~~
- 지속적 배포
  - 고객에게 젶무을 보여주지 않은채 진행하는 기간이 길수록 위험과 비용이 커집니다.  심지어 개발자 사기마저 떨어뜨릴 수 있습니다. 구글은 작업 결과의 효과를 빠르게 확인하고 변화하는 시장에 더 빨리 적응할수 있도록 조기에 자주 릴리스하라고 (혹은 출시 후 반복하라고) 독려합니다. 코드의 가치는 서브밋 시점이 아니라 고객이 그 기능을 이용할때 실현됩니다. 코드 완성과 사용자 피드백 사이의 시간을 단축할수록 진행 중인 작업의 비용이 줄어듭니다.  (p644)
  - 지속적 배포 이디엄 @ 구글
    - 민첩성 : 자주 작게 릴리즈 한다. 배포를 관리 가능한 조각으로 나누기
    - 자동화 : 잦은 릴리즈에 수반되는 반복 작업 부담을 줄이거나 없앱니다.
    - 격리 : 변경을 격리하여 문제를 쉽게 해결할수 있도록 모듈화된 아키텍처를 지향합니다. 기능 플래그로 보호하기
    - 신뢰성 : 비정상 종료와 지연시간 같은 주요 상태 지표를 측정하고 꾸준히 개선합니다.   쓰일 기능만 배포해야 합니다. 
    - 데이터 중심 의사결정 : A/B 실험으로 상대 지표를 비교하여 품질을 높입니다.
    - 단계적 출시 : 변경을 모두에게 동시에 출시하지 않고 소수의 사용자부터 이용해보게 합니다. 
- 서비스형 컴퓨트 (compute as a service)
  - me : ssh를 이용한 rsh로 시스템의 부하가 적은 곳을 찾아서 필요한 내용을 수행하도록 하는 script를 만들어 사용하면 어떨까?  처음 시작을 할때 각 서버의 사용량을 취합하는 shell을 돌려서 그중 선택된 서버에 해당 일을 맡기는 것이다. (물론 중간에 바꿀수는 없지만 이렇게만 해도 우리 서버들을 더 효과적으로 사용할수 있지 않을까?)  서버에서의 compile 시간도 적어두면 좋을 듯! (HDD와 CPU 의 차이 고려 -> 이런 부분은 아무도 사용하지 않는 새벽에 값을 뽑게해야 할 것으로 보인다. 새벽에 실제 수행하는 내용들도 동기화하게 하면 좋을 듯!)
  - 컨테이너 기반 아키텍처를 십분 활용하려면 애플리케이션을 '가축'처럼 다뤄도 되게끔 설계해야 합니다.   (복제 쉽게 한다. 1번 복제양 , 2번 복제양)

## 김진형 교수님의 책을 보는 중  - 204.06
- ![AI 최강의 수업](ai_lecture01.png) - millie
- 화면에서 내가 하는 일을 데이터화한다. 화면을 클릭하거나 넘기면 해당 이미지들을 저장을 해둔다. 
- 클릭하거나 드래그한 위치들을 기억하고 해당 내용이 무엇인지 알면 그 내용을 저장한다.
- 이것을 AI가 분석하여 동일한 작업을 할수 있게 만들수 있지 않을까?